# CS-305
Repository for CS-305 course.

**Artemis Financial – Practices for Secure Software**

Artemis Financial is a financial consulting company that develops individualized plans for savings, retirement, investments, and insurance. The organization wanted to modernize its RESTful web application while strengthening its overall security posture. As part of the development team at Global Rain, I was responsible for improving secure communications and implementing stronger software security controls. The primary requirement was to add a file verification mechanism in the form of a checksum and ensure encrypted communication to protect sensitive financial data from external threats.

To evaluate the application’s security posture, I conducted static dependency analysis using OWASP Dependency-Check. The initial scan revealed numerous vulnerabilities across outdated framework and server components, including Spring Boot and Apache Tomcat dependencies. After identifying the risks, I refactored the application to implement SHA-256 hashing using Java’s MessageDigest class to provide data integrity verification. I generated a self-signed SSL certificate using Java Keytool and configured the application to enforce HTTPS communication over port 8443. Once the refactor was complete, I ran a second static dependency scan to confirm that no new vulnerabilities had been introduced. This ensured that the security improvements strengthened the system without expanding its attack surface.

Secure coding is critical in financial systems because vulnerabilities can directly impact confidentiality, integrity, and availability. Weak encryption, insecure endpoints, or outdated libraries can lead to remote code execution, data breaches, and service disruption. Implementing encryption and integrity verification adds long-term value by protecting customer trust, supporting regulatory compliance, and reducing operational risk. This project reinforced that security must be integrated into development, testing, and deployment rather than treated as a final checklist item.

The most challenging aspect of this project was the manual review of the code base and understanding how insecure configurations and outdated dependencies create real-world risk. Initially, identifying vulnerable patterns required extensive research and careful inspection. Over time, I developed a more structured approach to analyzing code, validating weaknesses, and confirming remediation steps through static testing. This significantly strengthened my confidence in evaluating and refactoring production-level applications.

Security improvements were implemented in multiple layers. Data in transit is now protected through TLS encryption, and data integrity is verified using SHA-256 checksum validation. Functional testing confirmed that the application runs without errors and successfully returns a checksum response over HTTPS. By establishing a baseline scan before refactoring and comparing it to the post-refactor results, I ensured that the application remained stable while its security posture improved.

Throughout this project, I used OWASP Dependency-Check for software composition analysis, Java Keytool for certificate generation, and secure coding guidelines to guide implementation decisions. This approach reflects a DevSecOps mindset in which security testing is embedded into the development process rather than applied after deployment.

If presenting this project to future employers, I would highlight the checksum controller implementation, the HTTPS configuration within the Spring Boot application, and the before-and-after dependency analysis results. This artifact demonstrates applied experience in secure communications, cryptographic implementation, vulnerability analysis, and secure refactoring within a real-world web application.
